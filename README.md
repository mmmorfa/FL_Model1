
# **Federated Deep Reinforcement Learning System for Smart Cities**

This repository contains the implementation of a **Federated Deep Reinforcement Learning (FDRL)** system designed for resource allocation in smart city environments. The system leverages O-RAN components to manage radio and MEC resources efficiently across different traffic profiles. 

The use case scenario simulates a smart city with four nodes, each representing a near-RT RIC instance handling unique traffic profiles. Federated Learning (FL) is employed to train DQN-based resource allocation models collaboratively across these nodes while maintaining data privacy.

---

## **Repository Structure**

### **Folders**
1. **Certificates**:
   - Contains the certificates and keys required for enabling secure TLS communication between the server (rApp) and clients (xApps).

2. **Tests**:
   - Includes scripts and plots for performance evaluations conducted during the federated training phase.

3. **Trained_Models**:
   - Contains the exported DQN models:
     - Models 1 (dedicated to slice admission control).
     - Models 2 (dedicated to maintaining QoS).

4. **gym_examples**:
   - Includes environments and wrappers implemented using the **Stable Baselines3** framework for both centralized and federated design stages.

5. **logs**:
   - Stores the training logs generated by each client during the federated learning phase.

---

### **Key Files and Scripts**
- **`DQN_client_fw.py`**:
  - Implements the integration of Stable Baselines3 DQN models with the Flower Client class for FL.

- **`Global_Parameters.db`**:
  - A database used by Models 1 and 2 to manage the current status of processed slice requests.

- **`agent_evaluate_individual.py`**:
  - Evaluates individual DQN models obtained after FL training.

- **`agent_evaluate_system.py`**:
  - Evaluates the entire system of a single node, including Models 1 and 2 and their interactions with the global database.
  - Generates plots for rewards obtained during the evaluation period.

- **`certificates_generator.sh`**:
  - Script to generate all necessary TLS certificates and keys for secure server-client communication.

- **`client1_Model1.py`, `client2_Model1.py`, `client3_Model1.py`, `client4_Model1.py`**:
  - Define and configure the respective DQN Models 1 for each node.
  - Start the nodes as Flower Clients for the FL system.

- **`parse_logs.py`**:
  - Parses training logs and generates visualizations of the results.

- **`server.py`**:
  - Configures and starts the aggregation server for the FL system.

- **`setup.py`**:
  - Supports the execution of Stable Baselines3 for the DQN models.

---

## **System Overview**

### **Architecture**
- **Server**:
  - Deployed as a **rApp** in the non-RT RIC of the smart city.
  - Manages the aggregation of DQN models from the clients using FL.
- **Clients**:
  - Four near-RT RIC nodes, each hosting:
    - **Model 1**: Handles slice admission control for radio and MEC resources.
    - **Model 2**: Ensures QoS for processed slices.

### **Communication**
- Secure TLS communication is established between the server and clients using the certificates in the `Certificates` folder.

---

## **Usage Instructions**

### **Installing required dependencies**
Install the dependencies required to use the Stable Baselines3 framework by executing the following command:

`pip install stable-baselines3[extra]`

Install the required dependencies to use the Flower framework by executing the following command:

`pip install flwr`

### **1. Training Phase**
The following steps outline the training process for the FDRL system:

1. **Configure Traffic Profiles**:
   - Modify `ARRIVAL_RATE` and `LIFE_CYCLE_RATE` variables in the corresponding environment files in `gym_examples/envs/` to simulate the desired traffic profile for each node.

2. **Generate TLS Certificates**:
   - Run `certificates_generator.sh` to generate required certificates for server-client communication.

3. **Start the Server**:
   - Configure aggregation parameters and start the server by running `server.py`.

4. **Start the Clients**:
   - Configure DQN hyperparameters in `client1_Model1.py`, `client2_Model1.py`, `client3_Model1.py`, and `client4_Model1.py`.
   - Start each client by running the corresponding script.

5. **Analyze Training Logs**:
   - After training is completed, use `parse_logs.py` to visualize training results.

---

### **2. Evaluation Phase**
Evaluate the performance of individual nodes, including Models 1 and 2, and their interactions with the global database.

1. **Configure the Environment**:
   - Adjust traffic profiles in the selected environment for Model 1.

2. **Load Trained Models**:
   - Load the desired DQN Model 1 and Model 2 from the `Trained_Models` folder.

3. **Set Evaluation Parameters**:
   - Modify the evaluation period by adjusting the `while` loop condition in `agent_evaluate_system.py` and the `NUM_VNF_REQUESTS` variable in the "VNF Generator GLOBALS" section of the selected environment.

4. **Run Evaluation**:
   - Execute `agent_evaluate_system.py` to evaluate the selected node and generate performance plots.

### **3. Visualization of training results**
As defined in the initialization method of the `DQNClient` class developed in the `DQN_client_fw.py` script, the logs of each client's training process are automatically exported to a subfolder identified with the unique identifier of each implemented client. This is achieved using the Logger class provided by Stable Baselines3, which allows exporting such results in various formats and in key/value pairs. Depending on the algorithm used and the wrappers/callbacks applied, Stable Baselines3 logs a subset of these keys during training.

Once training is complete, the `parse_logs.py` script can be run to interpret the exported logs and generate the result plots discussed during this report. 

The `parse_and_plot_all_rounds` function receives each client's log files that need to be visualized (including the path of the respective logs in the `log_files` variable) and plots the required results parameter. 

To add plots to the results visualization it is necessary to include the code for a new plot following the format:

```
for round_idx, round_df in enumerate(rounds, start=1):
   plt.plot(round_df['time/total_timesteps'],
            round_df['rollout/exploration_rate'], 
            label=f'Round {round_idx}', color=colors[round_idx - 1])
```

where the `round_df` dictionary keys corresponding to the parameters to be displayed are substituted. This loop iterates through all the rounds in which the client participates.

---

## **Features**

- **Federated Training**:
  - Secure and collaborative model training using the Flower framework.
- **Dynamic Resource Management**:
  - DQN-based slicing for radio and MEC resources.
- **Traffic Profile Simulation**:
  - Four distinct profiles reflecting real-world scenarios (e.g., urban dense, highway mobility).
- **QoS Management**:
  - Model 2 ensures optimized quality of service across slices.
- **Evaluation and Visualization**:
  - Detailed analysis of training and evaluation phases with plots.

---

## **Contributors**
Developed and maintained by [mmmorfa](https://github.com/mmmorfa).

This work was supported by the Spanish Ministry of Economic Affairs and Digital Transformation and the European Union—NextGenerationEU, in the framework of the Recovery Plan, Transformation and Resilience (PRTR) (Call UNICO I+D 5G 2021, ref. number TSI-063000-2021-3/6/7–OPEN6G), and by the Agencia Estatal de Investigacion of Ministerio de Ciencia e Innovacion of Spain under project PID2022-137329OB-C41/ MCIN/ AEI/10.13039/50110001103.

---

For questions, issues, or contributions, feel free to open an issue or submit a pull request in this repository!
